'use strict';

var aboveSuite = function aboveSuite(getData) {
  return function () {
    var data = undefined;

    before(function () {
      data = getData();
    });

    // By default `above` is closed
    it('is a closed bound by default', assertCompletes(function () {
      return data.order('id').above({ id: 5 }).fetch({ asCursor: false }).do(function (res) {
        return assert.deepEqual(res, [{ id: 5, a: 60 }, { id: 6, a: 50 }]);
      });
    }));

    // We can also pass that explicitly
    it('allows "closed" to be passed explicitly', assertCompletes(function () {
      return data.order('id').above({ id: 5 }, 'closed').fetch({ asCursor: false }).do(function (res) {
        return assert.deepEqual(res, [{ id: 5, a: 60 }, { id: 6, a: 50 }]);
      });
    }));

    // But we can make it open
    it('can return an open bounded result', assertCompletes(function () {
      return data.order('id').above({ id: 5 }, 'open').fetch().do(function (res) {
        return assert.deepEqual(res, { id: 6, a: 50 });
      });
    }));

    // Let's try something that returns no values
    it('returns no results if bound eliminates all documents', assertCompletes(function () {
      return data.order('id').above({ id: 7 }).fetch().do(function () {
        return assert.fail();
      });
    }));

    // We can chain `above` off a collection
    it('can be chained from a collection directly', assertCompletes(function () {
      return data.above({ id: 5 }).fetch({ asCursor: false }).do(function (res) {
        assert.isArray(res);
        assert.lengthOf(res, 2);
      });
    }));

    // Or off other things
    it('can be chained from a findAll', assertCompletes(function () {
      return data.findAll({ a: 20 }).above({ id: 3 }).fetch({ asCursor: false }).do(function (res) {
        assert.isArray(res);
        assert.lengthOf(res, 2);
      });
    }));

    // `above` can't include any keys that are in `findAll`
    it('errors when it contains any keys from the findAll term', assertErrors(function () {
      return data.findAll({ a: 20 }).above({ a: 3 }).fetch();
    }));

    // Let's try it on a non-primary key
    it('can be used on a non-primary key', assertCompletes(function () {
      return data.order(['a', 'id']).above({ a: 20 }).fetch({ asCursor: false }).do(function (res) {
        return assert.deepEqual(res, [{ id: 2, a: 20, b: 1 }, { id: 3, a: 20, b: 2 }, { id: 4, a: 20, b: 3 }, { id: 6, a: 50 }, { id: 5, a: 60 }]);
      });
    }));

    // Let's try it on a non-primary key, but open
    it('can be used on non-primary key with open bound', assertCompletes(function () {
      return data.order(['a', 'id']).above({ a: 20 }, 'open').fetch({ asCursor: false }).do(function (res) {
        return assert.deepEqual(res, [{ id: 6, a: 50 }, { id: 5, a: 60 }]);
      });
    }));
    // The key in `above` must be the first key in `order`
    it('must receive as an argument the first key in the order term', assertErrors(function () {
      return data.order(['a', 'id']).above({ id: 20 }).fetch();
    }));

    // Passing multiple keys to `above` isn't legal
    it('errors if multiple keys are passed', assertErrors(function () {
      return data.order(['a', 'id']).above({ a: 20, id: 20 }).fetch();
    }));

    // Nor is passing a field that isn't specified in `order`
    it('errors if the field passed isn\'t in the order term', assertErrors(function () {
      return data.order(['a', 'id']).above({ b: 20 }).fetch();
    }));

    // If chaining `above/below`, they must be passed the same key
    it('errors if it doesn\'t receive the same key as the below term', assertErrors(function () {
      return data.above({ b: 0 }).below({ a: 100 }).fetch();
    }));

    // Starting with `null` is not ok
    it('throws if it is passed null', assertThrows('The 1st argument to above must be non-null', function () {
      return data.above(null).fetch();
    }));

    // Empty value is not ok
    it('throws if it does not receive an argument', assertThrows('above must receive at least 1 argument.', function () {
      return data.above().fetch();
    }));

    // Bad arguments are not ok
    it('errors if it receives a non-string argument', assertErrors(function () {
      return data.above(1).fetch();
    }));
    it('errors if it receives more than one argument', assertErrors(function () {
      return data.above({ id: 1 }, 1).fetch();
    }));
  };
}; // Testing `above`